# OIDC Authentication Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add `authMode: "oidc"` to the relay — OIDC authorization code flow for the admin web UI, RFC 8628 device flow for `cw setup`.

**Architecture:** New parallel OIDC tables in SQLite alongside existing GitHub tables (no schema breakage). `OIDCProvider` struct in `internal/oauth/oidc.go` handles discovery and token exchange; device flow endpoints live in `relay.go`. `cw setup <url>` auto-detects OIDC mode via `/api/v1/auth/config` and runs device flow.

**Tech Stack:** Go stdlib only (net/http, encoding/json, crypto/rand). No new dependencies. Existing: cobra, BurntSushi/toml, modernc.org/sqlite.

---

## Context

The relay lives in `internal/relay/`. Auth is in `internal/oauth/`. Store interface is `internal/store/store.go`, SQLite impl in `internal/store/sqlite.go`. CLI commands in `cmd/cw/main.go`. Setup flow in `internal/relay/setup.go`.

Current auth modes: `github` (GitHub OAuth App, GitHub-specific), `token` (shared secret), `none`. We add `oidc` alongside these.

The OIDC provider (Codewire.sh Dex) exposes a standard discovery document at `<issuer>/.well-known/openid-configuration`. Groups come from the `groups` claim in the userinfo endpoint response (Dex + Gitea connector includes groups).

**Do not remove existing GitHub auth code** — keep it working for backwards compat.

---

## Task 1: OIDC store types and interface

**Files:**
- Modify: `internal/store/store.go`
- Test: `internal/store/sqlite_test.go`

### Step 1: Write the failing tests

Add to `internal/store/sqlite_test.go`:

```go
func TestOIDCUserUpsertAndGet(t *testing.T) {
    s := newTestStore(t)
    ctx := context.Background()

    user := OIDCUser{
        Sub:         "CgVub2VsEgZnaXRlYQ",
        Username:    "noel",
        AvatarURL:   "https://example.com/avatar.png",
        CreatedAt:   time.Now().UTC().Truncate(time.Second),
        LastLoginAt: time.Now().UTC().Truncate(time.Second),
    }

    if err := s.OIDCUserUpsert(ctx, user); err != nil {
        t.Fatalf("OIDCUserUpsert: %v", err)
    }

    got, err := s.OIDCUserGetBySub(ctx, user.Sub)
    if err != nil {
        t.Fatalf("OIDCUserGetBySub: %v", err)
    }
    if got == nil {
        t.Fatal("expected user, got nil")
    }
    if got.Username != "noel" {
        t.Errorf("username = %q, want %q", got.Username, "noel")
    }
}

func TestOIDCSessionCreateGet(t *testing.T) {
    s := newTestStore(t)
    ctx := context.Background()

    // Must upsert user first (FK constraint).
    s.OIDCUserUpsert(ctx, OIDCUser{
        Sub: "sub123", Username: "alice",
        CreatedAt: time.Now().UTC(), LastLoginAt: time.Now().UTC(),
    })

    sess := OIDCSession{
        Token:     "sess_abc123",
        Sub:       "sub123",
        CreatedAt: time.Now().UTC().Truncate(time.Second),
        ExpiresAt: time.Now().UTC().Add(time.Hour).Truncate(time.Second),
    }
    if err := s.OIDCSessionCreate(ctx, sess); err != nil {
        t.Fatalf("OIDCSessionCreate: %v", err)
    }

    got, err := s.OIDCSessionGet(ctx, "sess_abc123")
    if err != nil {
        t.Fatalf("OIDCSessionGet: %v", err)
    }
    if got == nil {
        t.Fatal("expected session, got nil")
    }
    if got.Sub != "sub123" {
        t.Errorf("sub = %q, want %q", got.Sub, "sub123")
    }

    if err := s.OIDCSessionDelete(ctx, "sess_abc123"); err != nil {
        t.Fatalf("OIDCSessionDelete: %v", err)
    }
    got2, _ := s.OIDCSessionGet(ctx, "sess_abc123")
    if got2 != nil {
        t.Error("expected nil after delete")
    }
}

func TestOIDCDeviceFlow(t *testing.T) {
    s := newTestStore(t)
    ctx := context.Background()

    flow := OIDCDeviceFlow{
        PollToken:  "poll_xyz",
        DeviceCode: "dex_device_code_abc",
        NodeName:   "my-node",
        ExpiresAt:  time.Now().UTC().Add(5 * time.Minute),
    }
    if err := s.OIDCDeviceFlowCreate(ctx, flow); err != nil {
        t.Fatalf("OIDCDeviceFlowCreate: %v", err)
    }

    got, err := s.OIDCDeviceFlowGet(ctx, "poll_xyz")
    if err != nil {
        t.Fatalf("OIDCDeviceFlowGet: %v", err)
    }
    if got == nil {
        t.Fatal("expected flow, got nil")
    }
    if got.NodeToken != "" {
        t.Errorf("node_token should be empty before completion, got %q", got.NodeToken)
    }

    if err := s.OIDCDeviceFlowComplete(ctx, "poll_xyz", "node_tok_123"); err != nil {
        t.Fatalf("OIDCDeviceFlowComplete: %v", err)
    }

    got2, _ := s.OIDCDeviceFlowGet(ctx, "poll_xyz")
    if got2 == nil {
        t.Fatal("expected flow after complete, got nil")
    }
    if got2.NodeToken != "node_tok_123" {
        t.Errorf("node_token = %q, want %q", got2.NodeToken, "node_tok_123")
    }
}
```

### Step 2: Run tests to verify they fail

```bash
cd /Users/noel/src/sonica/codewire
go test ./internal/store/... -run TestOIDC -v
```
Expected: compile error — types/methods not defined yet.

### Step 3: Add types and interface methods to store.go

Add to `internal/store/store.go` after the `Invite` struct:

```go
// OIDCUser represents a user authenticated via OIDC (any provider).
type OIDCUser struct {
	Sub         string    `json:"sub"`
	Username    string    `json:"username"`
	AvatarURL   string    `json:"avatar_url"`
	CreatedAt   time.Time `json:"created_at"`
	LastLoginAt time.Time `json:"last_login_at"`
}

// OIDCSession is an admin UI session backed by an OIDC login.
type OIDCSession struct {
	Token     string    `json:"token"`
	Sub       string    `json:"sub"`
	CreatedAt time.Time `json:"created_at"`
	ExpiresAt time.Time `json:"expires_at"`
}

// OIDCDeviceFlow tracks an in-flight RFC 8628 device authorization request.
// PollToken is an opaque value given to the CLI to poll for completion.
// DeviceCode is the code used to poll the OIDC provider's token endpoint.
type OIDCDeviceFlow struct {
	PollToken  string    `json:"poll_token"`
	DeviceCode string    `json:"device_code"`
	NodeName   string    `json:"node_name"`
	NodeToken  string    `json:"node_token"` // populated by OIDCDeviceFlowComplete
	ExpiresAt  time.Time `json:"expires_at"`
}
```

Add to the `Store` interface (after the Invites section):

```go
	// OIDC Users.
	OIDCUserUpsert(ctx context.Context, user OIDCUser) error
	OIDCUserGetBySub(ctx context.Context, sub string) (*OIDCUser, error)

	// OIDC Sessions.
	OIDCSessionCreate(ctx context.Context, sess OIDCSession) error
	OIDCSessionGet(ctx context.Context, token string) (*OIDCSession, error)
	OIDCSessionDelete(ctx context.Context, token string) error

	// OIDC Device Flows.
	OIDCDeviceFlowCreate(ctx context.Context, flow OIDCDeviceFlow) error
	OIDCDeviceFlowGet(ctx context.Context, pollToken string) (*OIDCDeviceFlow, error)
	OIDCDeviceFlowComplete(ctx context.Context, pollToken, nodeToken string) error
```

### Step 4: Run tests to verify they still fail (interface not implemented)

```bash
go test ./internal/store/... -run TestOIDC -v
```
Expected: compile error — SQLiteStore does not implement Store (missing methods).

### Step 5: Commit

```bash
git add internal/store/store.go internal/store/sqlite_test.go
git commit -m "test: add OIDC store types and failing tests"
```

---

## Task 2: SQLite implementation of OIDC store methods

**Files:**
- Modify: `internal/store/sqlite.go`

### Step 1: Add migrations to sqlite.go

Find the `migrate()` method and add three new migrations at the end of the `migrations` slice:

```go
`CREATE TABLE IF NOT EXISTS oidc_users (
    sub TEXT PRIMARY KEY,
    username TEXT NOT NULL DEFAULT '',
    avatar_url TEXT NOT NULL DEFAULT '',
    created_at DATETIME NOT NULL,
    last_login_at DATETIME NOT NULL
)`,
`CREATE TABLE IF NOT EXISTS oidc_sessions (
    token TEXT PRIMARY KEY,
    sub TEXT NOT NULL REFERENCES oidc_users(sub),
    created_at DATETIME NOT NULL,
    expires_at DATETIME NOT NULL
)`,
`CREATE TABLE IF NOT EXISTS oidc_device_flows (
    poll_token TEXT PRIMARY KEY,
    device_code TEXT NOT NULL,
    node_name TEXT NOT NULL,
    node_token TEXT NOT NULL DEFAULT '',
    expires_at DATETIME NOT NULL
)`,
```

Also add `oidc_sessions` and `oidc_device_flows` to the `cleanupLoop`:
```go
s.db.Exec("DELETE FROM oidc_sessions WHERE expires_at < ?", now)
s.db.Exec("DELETE FROM oidc_device_flows WHERE expires_at < ?", now)
```

### Step 2: Implement the OIDC methods

Add after the `// --- Invites ---` section in sqlite.go:

```go
// --- OIDC Users ---

func (s *SQLiteStore) OIDCUserUpsert(_ context.Context, user OIDCUser) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	_, err := s.db.Exec(
		`INSERT INTO oidc_users (sub, username, avatar_url, created_at, last_login_at)
		 VALUES (?, ?, ?, ?, ?)
		 ON CONFLICT (sub) DO UPDATE SET
		   username = excluded.username,
		   avatar_url = excluded.avatar_url,
		   last_login_at = excluded.last_login_at`,
		user.Sub, user.Username, user.AvatarURL, user.CreatedAt, user.LastLoginAt,
	)
	return err
}

func (s *SQLiteStore) OIDCUserGetBySub(_ context.Context, sub string) (*OIDCUser, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	var u OIDCUser
	err := s.db.QueryRow(
		"SELECT sub, username, avatar_url, created_at, last_login_at FROM oidc_users WHERE sub = ?",
		sub,
	).Scan(&u.Sub, &u.Username, &u.AvatarURL, &u.CreatedAt, &u.LastLoginAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &u, nil
}

// --- OIDC Sessions ---

func (s *SQLiteStore) OIDCSessionCreate(_ context.Context, sess OIDCSession) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	_, err := s.db.Exec(
		"INSERT INTO oidc_sessions (token, sub, created_at, expires_at) VALUES (?, ?, ?, ?)",
		sess.Token, sess.Sub, sess.CreatedAt, sess.ExpiresAt,
	)
	return err
}

func (s *SQLiteStore) OIDCSessionGet(_ context.Context, token string) (*OIDCSession, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	var sess OIDCSession
	err := s.db.QueryRow(
		"SELECT token, sub, created_at, expires_at FROM oidc_sessions WHERE token = ? AND expires_at > ?",
		token, time.Now().UTC(),
	).Scan(&sess.Token, &sess.Sub, &sess.CreatedAt, &sess.ExpiresAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &sess, nil
}

func (s *SQLiteStore) OIDCSessionDelete(_ context.Context, token string) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	_, err := s.db.Exec("DELETE FROM oidc_sessions WHERE token = ?", token)
	return err
}

// --- OIDC Device Flows ---

func (s *SQLiteStore) OIDCDeviceFlowCreate(_ context.Context, flow OIDCDeviceFlow) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	_, err := s.db.Exec(
		"INSERT INTO oidc_device_flows (poll_token, device_code, node_name, node_token, expires_at) VALUES (?, ?, ?, '', ?)",
		flow.PollToken, flow.DeviceCode, flow.NodeName, flow.ExpiresAt,
	)
	return err
}

func (s *SQLiteStore) OIDCDeviceFlowGet(_ context.Context, pollToken string) (*OIDCDeviceFlow, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	var f OIDCDeviceFlow
	err := s.db.QueryRow(
		"SELECT poll_token, device_code, node_name, node_token, expires_at FROM oidc_device_flows WHERE poll_token = ? AND expires_at > ?",
		pollToken, time.Now().UTC(),
	).Scan(&f.PollToken, &f.DeviceCode, &f.NodeName, &f.NodeToken, &f.ExpiresAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &f, nil
}

func (s *SQLiteStore) OIDCDeviceFlowComplete(_ context.Context, pollToken, nodeToken string) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	res, err := s.db.Exec(
		"UPDATE oidc_device_flows SET node_token = ? WHERE poll_token = ? AND expires_at > ?",
		nodeToken, pollToken, time.Now().UTC(),
	)
	if err != nil {
		return err
	}
	n, _ := res.RowsAffected()
	if n == 0 {
		return fmt.Errorf("device flow not found or expired")
	}
	return nil
}
```

### Step 3: Run tests

```bash
go test ./internal/store/... -v
```
Expected: all tests pass including the three new TestOIDC* tests.

### Step 4: Commit

```bash
git add internal/store/sqlite.go
git commit -m "feat: add OIDC user/session/device-flow tables to SQLite store"
```

---

## Task 3: Update AuthIdentity to carry OIDC subject

**Files:**
- Modify: `internal/oauth/session.go`

### Step 1: Update AuthIdentity struct

In `internal/oauth/session.go`, change `AuthIdentity` from:
```go
type AuthIdentity struct {
	UserID   int64
	Username string
	IsAdmin  bool
}
```
to:
```go
// AuthIdentity represents who made the request.
type AuthIdentity struct {
	// UserID is the GitHub user ID (0 if OIDC or admin token auth).
	UserID int64
	// Sub is the OIDC subject claim ("" if GitHub or admin token auth).
	Sub string
	// Username is the authenticated username.
	Username string
	// IsAdmin is true if authenticated via admin token.
	IsAdmin bool
}
```

### Step 2: Update resolveToken to check OIDC sessions

Change the `resolveToken` function to also check OIDC sessions:

```go
func resolveToken(ctx context.Context, st store.Store, adminToken, token string) *AuthIdentity {
	// Session tokens start with sess_.
	if strings.HasPrefix(token, sessionTokenPrefix) {
		// Try OIDC session first.
		if oidcSess, err := st.OIDCSessionGet(ctx, token); err == nil && oidcSess != nil {
			username := ""
			if user, err := st.OIDCUserGetBySub(ctx, oidcSess.Sub); err == nil && user != nil {
				username = user.Username
			}
			return &AuthIdentity{Sub: oidcSess.Sub, Username: username}
		}

		// Fall back to GitHub session.
		sess, err := st.SessionGet(ctx, token)
		if err != nil || sess == nil {
			return nil
		}
		if time.Now().After(sess.ExpiresAt) {
			return nil
		}
		user, err := st.UserGetByID(ctx, sess.GitHubID)
		if err != nil || user == nil {
			return nil
		}
		return &AuthIdentity{
			UserID:   user.GitHubID,
			Username: user.Username,
		}
	}

	// Check admin token.
	if adminToken != "" && token == adminToken {
		return &AuthIdentity{IsAdmin: true}
	}

	return nil
}
```

### Step 3: Build to verify no compile errors

```bash
go build ./...
```
Expected: builds clean.

### Step 4: Commit

```bash
git add internal/oauth/session.go
git commit -m "feat: add OIDC Sub field to AuthIdentity, check OIDC sessions in resolveToken"
```

---

## Task 4: OIDC provider — discovery and authorization code flow

**Files:**
- Create: `internal/oauth/oidc.go`
- Create: `internal/oauth/oidc_test.go`

### Step 1: Write failing tests

Create `internal/oauth/oidc_test.go`:

```go
package oauth

import (
	"testing"
)

func TestCheckGroups_EmptyAllowed(t *testing.T) {
	p := &OIDCProvider{AllowedGroups: nil}
	if err := p.checkGroups([]string{"any-group"}); err != nil {
		t.Errorf("empty allowedGroups should allow all, got: %v", err)
	}
}

func TestCheckGroups_Match(t *testing.T) {
	p := &OIDCProvider{AllowedGroups: []string{"sonica", "admins"}}
	if err := p.checkGroups([]string{"sonica"}); err != nil {
		t.Errorf("expected allow for matching group, got: %v", err)
	}
}

func TestCheckGroups_NoMatch(t *testing.T) {
	p := &OIDCProvider{AllowedGroups: []string{"sonica"}}
	if err := p.checkGroups([]string{"other-team"}); err == nil {
		t.Error("expected deny for non-matching group")
	}
}

func TestCheckGroups_EmptyUserGroups(t *testing.T) {
	p := &OIDCProvider{AllowedGroups: []string{"sonica"}}
	if err := p.checkGroups(nil); err == nil {
		t.Error("expected deny for user with no groups")
	}
}
```

### Step 2: Run to verify they fail

```bash
go test ./internal/oauth/... -run TestCheckGroups -v
```
Expected: compile error — OIDCProvider not defined.

### Step 3: Create internal/oauth/oidc.go

```go
package oauth

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/codewiresh/codewire/internal/store"
)

// OIDCProvider handles OIDC discovery and authentication flows.
// Call Discover() before using any handler methods.
type OIDCProvider struct {
	Issuer        string
	ClientID      string
	ClientSecret  string
	AllowedGroups []string

	// Populated by Discover().
	authEndpoint   string
	tokenEndpoint  string
	userinfoEndpoint string
	deviceEndpoint string
}

type oidcDiscovery struct {
	Issuer                      string `json:"issuer"`
	AuthorizationEndpoint       string `json:"authorization_endpoint"`
	TokenEndpoint               string `json:"token_endpoint"`
	UserinfoEndpoint            string `json:"userinfo_endpoint"`
	DeviceAuthorizationEndpoint string `json:"device_authorization_endpoint"`
}

// Discover fetches the OIDC discovery document and populates the provider endpoints.
// Must be called before using any handler methods.
func (p *OIDCProvider) Discover(ctx context.Context) error {
	discURL := strings.TrimRight(p.Issuer, "/") + "/.well-known/openid-configuration"
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, discURL, nil)
	if err != nil {
		return fmt.Errorf("creating discovery request: %w", err)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return fmt.Errorf("fetching OIDC discovery document from %s: %w", discURL, err)
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(io.LimitReader(resp.Body, 1<<20))
	if err != nil {
		return fmt.Errorf("reading discovery document: %w", err)
	}
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("discovery endpoint returned %d: %s", resp.StatusCode, body)
	}
	var doc oidcDiscovery
	if err := json.Unmarshal(body, &doc); err != nil {
		return fmt.Errorf("parsing discovery document: %w", err)
	}
	if doc.AuthorizationEndpoint == "" || doc.TokenEndpoint == "" {
		return fmt.Errorf("incomplete discovery document (missing authorization or token endpoint)")
	}
	p.authEndpoint = doc.AuthorizationEndpoint
	p.tokenEndpoint = doc.TokenEndpoint
	p.userinfoEndpoint = doc.UserinfoEndpoint
	p.deviceEndpoint = doc.DeviceAuthorizationEndpoint
	return nil
}

// checkGroups returns nil if the user is allowed. If AllowedGroups is empty,
// all authenticated users are allowed. Otherwise, the user must be in at least
// one of the allowed groups.
func (p *OIDCProvider) checkGroups(userGroups []string) error {
	if len(p.AllowedGroups) == 0 {
		return nil
	}
	for _, ag := range p.AllowedGroups {
		for _, ug := range userGroups {
			if ag == ug {
				return nil
			}
		}
	}
	return fmt.Errorf("not a member of any allowed group (%v)", p.AllowedGroups)
}

// userinfoClaims calls the userinfo endpoint and returns sub, username, groups.
func (p *OIDCProvider) userinfoClaims(ctx context.Context, accessToken string) (sub, username string, groups []string, err error) {
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, p.userinfoEndpoint, nil)
	if err != nil {
		return "", "", nil, fmt.Errorf("creating userinfo request: %w", err)
	}
	req.Header.Set("Authorization", "Bearer "+accessToken)
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", "", nil, fmt.Errorf("userinfo request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		b, _ := io.ReadAll(io.LimitReader(resp.Body, 512))
		return "", "", nil, fmt.Errorf("userinfo returned %d: %s", resp.StatusCode, b)
	}
	var claims struct {
		Sub               string   `json:"sub"`
		PreferredUsername string   `json:"preferred_username"`
		Name              string   `json:"name"`
		Groups            []string `json:"groups"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&claims); err != nil {
		return "", "", nil, fmt.Errorf("parsing userinfo response: %w", err)
	}
	name := claims.PreferredUsername
	if name == "" {
		name = claims.Name
	}
	return claims.Sub, name, claims.Groups, nil
}

// exchangeCode exchanges an authorization code for an access_token.
func (p *OIDCProvider) exchangeCode(ctx context.Context, code, redirectURI string) (string, error) {
	data := url.Values{
		"grant_type":    {"authorization_code"},
		"code":          {code},
		"redirect_uri":  {redirectURI},
		"client_id":     {p.ClientID},
		"client_secret": {p.ClientSecret},
	}
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, p.tokenEndpoint, strings.NewReader(data.Encode()))
	if err != nil {
		return "", fmt.Errorf("creating token request: %w", err)
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	req.Header.Set("Accept", "application/json")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", fmt.Errorf("token request: %w", err)
	}
	defer resp.Body.Close()
	body, _ := io.ReadAll(io.LimitReader(resp.Body, 1<<20))
	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("token endpoint returned %d: %s", resp.StatusCode, body)
	}
	var result struct {
		AccessToken string `json:"access_token"`
	}
	if err := json.Unmarshal(body, &result); err != nil {
		return "", fmt.Errorf("parsing token response: %w", err)
	}
	if result.AccessToken == "" {
		return "", fmt.Errorf("empty access_token in response: %s", body)
	}
	return result.AccessToken, nil
}

// LoginHandler initiates the OIDC authorization code flow.
// Registers: GET /auth/oidc
func (p *OIDCProvider) LoginHandler(st store.Store, baseURL string) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		state := GenerateState()
		if err := st.OAuthStateCreate(r.Context(), store.OAuthState{
			State:     state,
			CreatedAt: time.Now().UTC(),
			ExpiresAt: time.Now().UTC().Add(10 * time.Minute),
		}); err != nil {
			http.Error(w, "internal error", http.StatusInternalServerError)
			return
		}
		redirectURI := baseURL + "/auth/oidc/callback"
		authURL := fmt.Sprintf("%s?client_id=%s&redirect_uri=%s&response_type=code&scope=%s&state=%s",
			p.authEndpoint,
			url.QueryEscape(p.ClientID),
			url.QueryEscape(redirectURI),
			url.QueryEscape("openid profile email groups"),
			url.QueryEscape(state),
		)
		http.Redirect(w, r, authURL, http.StatusFound)
	}
}

// CallbackHandler handles the OIDC authorization code callback.
// Registers: GET /auth/oidc/callback
func (p *OIDCProvider) CallbackHandler(st store.Store, baseURL string) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		state := r.URL.Query().Get("state")
		if err := st.OAuthStateConsume(r.Context(), state); err != nil {
			http.Error(w, "invalid or expired state parameter", http.StatusBadRequest)
			return
		}
		code := r.URL.Query().Get("code")
		if code == "" {
			http.Error(w, "missing code parameter", http.StatusBadRequest)
			return
		}
		accessToken, err := p.exchangeCode(r.Context(), code, baseURL+"/auth/oidc/callback")
		if err != nil {
			http.Error(w, "token exchange failed: "+err.Error(), http.StatusBadGateway)
			return
		}
		sub, username, groups, err := p.userinfoClaims(r.Context(), accessToken)
		if err != nil {
			http.Error(w, "userinfo failed: "+err.Error(), http.StatusBadGateway)
			return
		}
		if err := p.checkGroups(groups); err != nil {
			http.Error(w, "access denied: "+err.Error(), http.StatusForbidden)
			return
		}
		now := time.Now().UTC()
		if err := st.OIDCUserUpsert(r.Context(), store.OIDCUser{
			Sub: sub, Username: username, CreatedAt: now, LastLoginAt: now,
		}); err != nil {
			http.Error(w, "internal error", http.StatusInternalServerError)
			return
		}
		sessToken := GenerateSessionToken()
		if err := st.OIDCSessionCreate(r.Context(), store.OIDCSession{
			Token: sessToken, Sub: sub, CreatedAt: now, ExpiresAt: now.Add(30 * 24 * time.Hour),
		}); err != nil {
			http.Error(w, "internal error", http.StatusInternalServerError)
			return
		}
		parsed, _ := url.Parse(baseURL)
		http.SetCookie(w, &http.Cookie{
			Name:     "cw_session",
			Value:    sessToken,
			Path:     "/",
			HttpOnly: true,
			Secure:   parsed != nil && parsed.Scheme == "https",
			SameSite: http.SameSiteLaxMode,
			MaxAge:   30 * 24 * 60 * 60,
		})
		http.Redirect(w, r, "/", http.StatusFound)
	}
}

// OIDCSessionInfoHandler returns the current OIDC user's session info as JSON.
// Registers: GET /auth/session (when authMode == "oidc")
func (p *OIDCProvider) OIDCSessionInfoHandler(st store.Store) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var token string
		if auth := r.Header.Get("Authorization"); strings.HasPrefix(auth, "Bearer ") {
			token = strings.TrimPrefix(auth, "Bearer ")
		}
		if token == "" {
			if cookie, err := r.Cookie("cw_session"); err == nil {
				token = cookie.Value
			}
		}
		if token == "" {
			http.Error(w, `{"error":"unauthorized"}`, http.StatusUnauthorized)
			return
		}
		sess, err := st.OIDCSessionGet(r.Context(), token)
		if err != nil || sess == nil {
			http.Error(w, `{"error":"unauthorized"}`, http.StatusUnauthorized)
			return
		}
		user, err := st.OIDCUserGetBySub(r.Context(), sess.Sub)
		if err != nil || user == nil {
			http.Error(w, `{"error":"user not found"}`, http.StatusUnauthorized)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"sub":        user.Sub,
			"username":   user.Username,
			"expires_at": sess.ExpiresAt,
		})
	}
}

// OIDCIndexHandler serves a simple status page when OIDC is configured.
// Registers: GET / (when authMode == "oidc")
func (p *OIDCProvider) OIDCIndexHandler(baseURL string) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/html")
		fmt.Fprintf(w, `<!DOCTYPE html>
<html><head><title>CodeWire Relay</title>
<style>
body{font-family:system-ui,-apple-system,sans-serif;max-width:480px;margin:80px auto;text-align:center;color:#1a1a1a}
h2{font-weight:600}
.badge{display:inline-block;padding:6px 16px;background:#dcfce7;color:#166534;border-radius:20px;font-size:14px;margin-top:8px}
a{color:#2563eb}
</style></head><body>
<h2>CodeWire Relay</h2>
<div class="badge">Relay is running</div>
<p><a href="/auth/oidc">Sign in</a></p>
</body></html>`)
	}
}
```

### Step 4: Run tests

```bash
go test ./internal/oauth/... -run TestCheckGroups -v
```
Expected: all 4 TestCheckGroups tests pass.

Also build check:
```bash
go build ./...
```
Expected: builds clean.

### Step 5: Commit

```bash
git add internal/oauth/oidc.go internal/oauth/oidc_test.go
git commit -m "feat: add OIDCProvider with discovery, auth code flow, group check"
```

---

## Task 5: OIDC device flow handlers in relay.go

**Files:**
- Modify: `internal/relay/relay.go`

The device flow HTTP handlers live in relay.go (not oauth package) because they call NodeRegister on the store — that's relay business logic.

### Step 1: Add deviceAuthorizeHandler to relay.go

Add after the `joinHandler` function in `internal/relay/relay.go`:

```go
// --- OIDC Device Flow ---

func deviceAuthorizeHandler(st store.Store, p *oauth.OIDCProvider) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req struct {
			NodeName string `json:"node_name"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil || req.NodeName == "" {
			http.Error(w, "node_name required", http.StatusBadRequest)
			return
		}

		// Ask Dex to start the device auth flow.
		data := url.Values{
			"client_id":     {p.ClientID},
			"client_secret": {p.ClientSecret},
			"scope":         {"openid profile email groups"},
		}
		dreq, err := http.NewRequestWithContext(r.Context(), http.MethodPost, p.DeviceEndpoint(), strings.NewReader(data.Encode()))
		if err != nil {
			http.Error(w, "internal error", http.StatusInternalServerError)
			return
		}
		dreq.Header.Set("Content-Type", "application/x-www-form-urlencoded")
		dreq.Header.Set("Accept", "application/json")
		dresp, err := http.DefaultClient.Do(dreq)
		if err != nil {
			http.Error(w, "OIDC provider unreachable: "+err.Error(), http.StatusBadGateway)
			return
		}
		defer dresp.Body.Close()
		body, _ := io.ReadAll(io.LimitReader(dresp.Body, 1<<20))
		if dresp.StatusCode != http.StatusOK {
			http.Error(w, fmt.Sprintf("OIDC provider returned %d: %s", dresp.StatusCode, body), http.StatusBadGateway)
			return
		}

		var dauth struct {
			DeviceCode      string `json:"device_code"`
			UserCode        string `json:"user_code"`
			VerificationURI string `json:"verification_uri"`
			ExpiresIn       int    `json:"expires_in"`
			Interval        int    `json:"interval"`
		}
		if err := json.Unmarshal(body, &dauth); err != nil {
			http.Error(w, "parsing device auth response: "+err.Error(), http.StatusBadGateway)
			return
		}

		expiresIn := 300
		if dauth.ExpiresIn > 0 {
			expiresIn = dauth.ExpiresIn
		}
		interval := 5
		if dauth.Interval > 0 {
			interval = dauth.Interval
		}

		flow := store.OIDCDeviceFlow{
			PollToken:  generateToken(),
			DeviceCode: dauth.DeviceCode,
			NodeName:   req.NodeName,
			ExpiresAt:  time.Now().UTC().Add(time.Duration(expiresIn) * time.Second),
		}
		if err := st.OIDCDeviceFlowCreate(r.Context(), flow); err != nil {
			http.Error(w, "internal error", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"poll_token":       flow.PollToken,
			"user_code":        dauth.UserCode,
			"verification_uri": dauth.VerificationURI,
			"expires_in":       expiresIn,
			"interval":         interval,
		})
	}
}

func devicePollHandler(st store.Store, p *oauth.OIDCProvider) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req struct {
			PollToken string `json:"poll_token"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil || req.PollToken == "" {
			http.Error(w, "poll_token required", http.StatusBadRequest)
			return
		}

		flow, err := st.OIDCDeviceFlowGet(r.Context(), req.PollToken)
		if err != nil {
			http.Error(w, "internal error", http.StatusInternalServerError)
			return
		}
		if flow == nil {
			http.Error(w, "expired or invalid poll token", http.StatusGone)
			return
		}

		// Already completed in a prior poll?
		if flow.NodeToken != "" {
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(map[string]string{
				"status":     "authorized",
				"node_token": flow.NodeToken,
				"node_name":  flow.NodeName,
			})
			return
		}

		// Poll Dex token endpoint for the device code.
		data := url.Values{
			"grant_type":    {"urn:ietf:params:oauth:grant-type:device_code"},
			"device_code":   {flow.DeviceCode},
			"client_id":     {p.ClientID},
			"client_secret": {p.ClientSecret},
		}
		treq, _ := http.NewRequestWithContext(r.Context(), http.MethodPost, p.TokenEndpoint(), strings.NewReader(data.Encode()))
		treq.Header.Set("Content-Type", "application/x-www-form-urlencoded")
		treq.Header.Set("Accept", "application/json")
		tresp, err := http.DefaultClient.Do(treq)
		if err != nil {
			http.Error(w, "polling OIDC provider: "+err.Error(), http.StatusBadGateway)
			return
		}
		defer tresp.Body.Close()
		body, _ := io.ReadAll(io.LimitReader(tresp.Body, 1<<20))

		var tokenResp struct {
			AccessToken string `json:"access_token"`
			Error       string `json:"error"`
		}
		json.Unmarshal(body, &tokenResp)

		if tokenResp.Error == "authorization_pending" || tokenResp.Error == "slow_down" {
			w.WriteHeader(http.StatusAccepted)
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(map[string]string{"status": "pending"})
			return
		}
		if tokenResp.Error != "" {
			http.Error(w, "device auth failed: "+tokenResp.Error, http.StatusForbidden)
			return
		}
		if tokenResp.AccessToken == "" {
			http.Error(w, "empty access_token from OIDC provider", http.StatusBadGateway)
			return
		}

		// Fetch claims and validate groups.
		sub, username, groups, err := p.UserinfoClaims(r.Context(), tokenResp.AccessToken)
		if err != nil {
			http.Error(w, "userinfo failed: "+err.Error(), http.StatusBadGateway)
			return
		}
		if err := p.CheckGroups(groups); err != nil {
			http.Error(w, "access denied: "+err.Error(), http.StatusForbidden)
			return
		}

		// Upsert user record.
		now := time.Now().UTC()
		st.OIDCUserUpsert(r.Context(), store.OIDCUser{
			Sub: sub, Username: username, CreatedAt: now, LastLoginAt: now,
		})

		// Register node with a new token.
		nodeToken := generateToken()
		if err := st.NodeRegister(r.Context(), store.NodeRecord{
			Name: flow.NodeName, Token: nodeToken,
			AuthorizedAt: now, LastSeenAt: now,
		}); err != nil {
			http.Error(w, "internal error", http.StatusInternalServerError)
			return
		}

		// Mark flow complete.
		if err := st.OIDCDeviceFlowComplete(r.Context(), req.PollToken, nodeToken); err != nil {
			http.Error(w, "internal error", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"status":     "authorized",
			"node_token": nodeToken,
			"node_name":  flow.NodeName,
		})
	}
}
```

Note: `devicePollHandler` calls `p.UserinfoClaims` and `p.CheckGroups` — these are the exported versions of the private methods. Update `internal/oauth/oidc.go` to export them:

In `oidc.go`, rename `userinfoClaims` → `UserinfoClaims` and `checkGroups` → `CheckGroups`, and add exported `DeviceEndpoint()` and `TokenEndpoint()` accessor methods:

```go
// DeviceEndpoint returns the discovered device authorization endpoint URL.
func (p *OIDCProvider) DeviceEndpoint() string { return p.deviceEndpoint }

// TokenEndpoint returns the discovered token endpoint URL.
func (p *OIDCProvider) TokenEndpoint() string { return p.tokenEndpoint }
```

Also update all internal callers of `userinfoClaims` → `UserinfoClaims` and `checkGroups` → `CheckGroups` in `oidc.go`.

### Step 2: Add needed import to relay.go

`relay.go` needs `"net/url"` and `"github.com/codewiresh/codewire/internal/oauth"` in imports. Check if `net/url` is already there — if not, add it.

### Step 3: Build check

```bash
go build ./...
```
Expected: builds clean.

### Step 4: Commit

```bash
git add internal/relay/relay.go internal/oauth/oidc.go
git commit -m "feat: add OIDC device flow handlers (deviceAuthorize, devicePoll)"
```

---

## Task 6: Wire OIDC into relay config and mux

**Files:**
- Modify: `internal/relay/relay.go`
- Modify: `cmd/cw/main.go`

### Step 1: Add OIDC fields to RelayConfig

In `relay.go`, add to `RelayConfig` struct:

```go
	// OIDCIssuer is the OIDC provider issuer URL (e.g. https://auth.codewire.sh).
	// Required when AuthMode is "oidc".
	OIDCIssuer string
	// OIDCClientID is the registered OIDC client ID.
	OIDCClientID string
	// OIDCClientSecret is the registered OIDC client secret.
	OIDCClientSecret string
	// OIDCAllowedGroups restricts access to members of these groups.
	// Empty means any authenticated user is allowed.
	OIDCAllowedGroups []string
```

### Step 2: Add OIDC branch to buildMux and auth/config endpoint

In `buildMux`, after the GitHub branch, add:

```go
	// OIDC auth (when AuthMode == "oidc").
	if cfg.AuthMode == "oidc" {
		oidcProvider := &oauth.OIDCProvider{
			Issuer:        cfg.OIDCIssuer,
			ClientID:      cfg.OIDCClientID,
			ClientSecret:  cfg.OIDCClientSecret,
			AllowedGroups: cfg.OIDCAllowedGroups,
		}
		if err := oidcProvider.Discover(context.Background()); err != nil {
			// Log but don't crash — relay will return 503 on auth endpoints.
			fmt.Fprintf(os.Stderr, "[relay] OIDC discovery failed: %v\n", err)
		}
		mux.HandleFunc("GET /auth/oidc", oidcProvider.LoginHandler(st, cfg.BaseURL))
		mux.HandleFunc("GET /auth/oidc/callback", oidcProvider.CallbackHandler(st, cfg.BaseURL))
		mux.HandleFunc("GET /auth/session", oidcProvider.OIDCSessionInfoHandler(st))
		mux.HandleFunc("GET /{$}", oidcProvider.OIDCIndexHandler(cfg.BaseURL))

		// Device flow (public, rate-limited same as join).
		mux.HandleFunc("POST /api/v1/device/authorize", rateLimitMiddleware(joinRL, deviceAuthorizeHandler(st, oidcProvider)))
		mux.HandleFunc("POST /api/v1/device/poll", devicePollHandler(st, oidcProvider))
	}
```

Add the auth config endpoint (always registered, any mode):

```go
	// Auth config discovery (unauthenticated, used by cw setup).
	mux.HandleFunc("GET /api/v1/auth/config", authConfigHandler(cfg.AuthMode))
```

Add the `authConfigHandler` function:

```go
func authConfigHandler(authMode string) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"auth_mode": authMode,
		})
	}
}
```

Also update `authMode` comment in the struct: `// AuthMode controls authentication: "oidc", "github", "token", "none".`

### Step 3: Add OIDC flags to relayCmd in main.go

In `relayCmd()`, add these variables:
```go
		oidcIssuer        string
		oidcClientID      string
		oidcClientSecret  string
		oidcAllowedGroups []string
```

Add to `relay.RunRelay(ctx, relay.RelayConfig{...})`:
```go
			OIDCIssuer:        oidcIssuer,
			OIDCClientID:      oidcClientID,
			OIDCClientSecret:  oidcClientSecret,
			OIDCAllowedGroups: oidcAllowedGroups,
```

Add flags:
```go
	cmd.Flags().StringVar(&oidcIssuer, "oidc-issuer", "", "OIDC provider issuer URL (for --auth-mode=oidc)")
	cmd.Flags().StringVar(&oidcClientID, "oidc-client-id", "", "OIDC client ID")
	cmd.Flags().StringVar(&oidcClientSecret, "oidc-client-secret", "", "OIDC client secret")
	cmd.Flags().StringSliceVar(&oidcAllowedGroups, "oidc-allowed-groups", nil, "OIDC groups required for access (empty = any)")
```

Also update `--auth-mode` description: `"Auth mode: oidc, github, token, none"`

### Step 4: Build check

```bash
go build ./...
```

### Step 5: Commit

```bash
git add internal/relay/relay.go cmd/cw/main.go
git commit -m "feat: wire OIDC into relay mux, add /api/v1/auth/config endpoint"
```

---

## Task 7: Update cw setup for OIDC device flow

**Files:**
- Modify: `internal/relay/setup.go`
- Modify: `cmd/cw/main.go`

### Step 1: Add OIDC device flow registration to setup.go

Add `registerWithDeviceFlow` to `setup.go`:

```go
// registerWithDeviceFlow performs RFC 8628 device authorization against the relay
// and returns the node token once the user approves in their browser.
func registerWithDeviceFlow(ctx context.Context, relayURL, nodeName string) (string, error) {
	// Step 1: initiate device auth.
	body, _ := json.Marshal(map[string]string{"node_name": nodeName})
	req, _ := http.NewRequestWithContext(ctx, http.MethodPost, relayURL+"/api/v1/device/authorize", bytes.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", fmt.Errorf("contacting relay: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		b, _ := io.ReadAll(io.LimitReader(resp.Body, 1024))
		return "", fmt.Errorf("device authorize failed (%d): %s", resp.StatusCode, b)
	}

	var dauth struct {
		PollToken       string `json:"poll_token"`
		UserCode        string `json:"user_code"`
		VerificationURI string `json:"verification_uri"`
		ExpiresIn       int    `json:"expires_in"`
		Interval        int    `json:"interval"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&dauth); err != nil {
		return "", fmt.Errorf("parsing device authorize response: %w", err)
	}

	// Step 2: prompt user.
	fmt.Fprintf(os.Stderr, "→ Open %s\n", dauth.VerificationURI)
	fmt.Fprintf(os.Stderr, "→ Enter code: %s\n", dauth.UserCode)
	fmt.Fprintf(os.Stderr, "→ Waiting for authorization...\n")

	// Step 3: poll until approved or expired.
	interval := time.Duration(dauth.Interval) * time.Second
	if interval < 5*time.Second {
		interval = 5 * time.Second
	}
	deadline := time.Now().Add(time.Duration(dauth.ExpiresIn) * time.Second)

	for time.Now().Before(deadline) {
		select {
		case <-ctx.Done():
			return "", ctx.Err()
		case <-time.After(interval):
		}

		pollBody, _ := json.Marshal(map[string]string{"poll_token": dauth.PollToken})
		preq, _ := http.NewRequestWithContext(ctx, http.MethodPost, relayURL+"/api/v1/device/poll", bytes.NewReader(pollBody))
		preq.Header.Set("Content-Type", "application/json")
		presp, err := http.DefaultClient.Do(preq)
		if err != nil {
			continue // network hiccup, retry
		}
		defer presp.Body.Close()

		if presp.StatusCode == http.StatusGone {
			return "", fmt.Errorf("device code expired")
		}
		if presp.StatusCode == http.StatusForbidden {
			b, _ := io.ReadAll(io.LimitReader(presp.Body, 512))
			return "", fmt.Errorf("authorization denied: %s", b)
		}
		if presp.StatusCode == http.StatusAccepted {
			// Still pending — continue polling.
			continue
		}
		if presp.StatusCode == http.StatusOK {
			var result struct {
				NodeToken string `json:"node_token"`
			}
			if err := json.NewDecoder(presp.Body).Decode(&result); err != nil {
				return "", fmt.Errorf("parsing poll response: %w", err)
			}
			return result.NodeToken, nil
		}
	}

	return "", fmt.Errorf("timed out waiting for authorization")
}
```

### Step 2: Update RunSetup to detect OIDC mode and use positional token

Update `SetupOptions`:
```go
type SetupOptions struct {
	RelayURL  string
	DataDir   string
	Token     string // invite token or admin token (empty = try OIDC device flow)
	AuthToken string // kept for backwards compat (--token flag for admin CI)
}
```

Update `RunSetup` switch statement:
```go
	switch {
	case opts.AuthToken != "":
		nodeToken, err = registerWithToken(ctx, opts.RelayURL, nodeName, opts.AuthToken)
	case opts.Token != "":
		// Detect if token looks like an invite (starts with CW-INV-) or admin token.
		nodeToken, err = registerWithInvite(ctx, opts.RelayURL, nodeName, opts.Token)
	default:
		// No token provided — check relay's auth mode.
		nodeToken, err = registerAutoDetect(ctx, opts.RelayURL, nodeName)
	}
```

Add `registerAutoDetect`:
```go
func registerAutoDetect(ctx context.Context, relayURL, nodeName string) (string, error) {
	// Fetch auth config from relay.
	req, _ := http.NewRequestWithContext(ctx, http.MethodGet, relayURL+"/api/v1/auth/config", nil)
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", fmt.Errorf("contacting relay: %w", err)
	}
	defer resp.Body.Close()

	var cfg struct {
		AuthMode string `json:"auth_mode"`
	}
	json.NewDecoder(resp.Body).Decode(&cfg)

	switch cfg.AuthMode {
	case "oidc":
		return registerWithDeviceFlow(ctx, relayURL, nodeName)
	default:
		return "", fmt.Errorf("relay auth mode is %q — provide a token: cw setup %s <token>", cfg.AuthMode, relayURL)
	}
}
```

### Step 3: Update setupCmd in main.go

Change `setupCmd()`:
- `Args: cobra.MaximumNArgs(1)` → `cobra.RangeArgs(1, 2)`
- `Use: "setup <relay-url> [token]"`
- Remove `--invite` flag
- Keep `--token` flag for admin/CI headless use

```go
func setupCmd() *cobra.Command {
	var authToken string

	cmd := &cobra.Command{
		Use:   "setup <relay-url> [token]",
		Short: "Connect this node to a relay",
		Long:  "Connect this node to a relay. With no token, uses OIDC device flow if the relay supports it.",
		Args:  cobra.RangeArgs(1, 2),
		RunE: func(cmd *cobra.Command, args []string) error {
			relayURL := args[0]
			var token string
			if len(args) > 1 {
				token = args[1]
			}

			dir := dataDir()
			if err := os.MkdirAll(dir, 0o755); err != nil {
				return fmt.Errorf("creating data dir: %w", err)
			}

			ctx, cancel := context.WithCancel(context.Background())
			defer cancel()
			sigCh := make(chan os.Signal, 1)
			signal.Notify(sigCh, syscall.SIGTERM, syscall.SIGINT)
			go func() { <-sigCh; cancel() }()

			return relay.RunSetup(ctx, relay.SetupOptions{
				RelayURL:  relayURL,
				DataDir:   dir,
				Token:     token,
				AuthToken: authToken,
			})
		},
	}

	cmd.Flags().StringVar(&authToken, "token", "", "Admin auth token (for headless/CI use)")
	return cmd
}
```

### Step 4: Build and test

```bash
go build ./...
go test ./internal/... -timeout 60s -count=1
```
Expected: builds and tests pass.

### Step 5: Commit

```bash
git add internal/relay/setup.go cmd/cw/main.go
git commit -m "feat: cw setup detects OIDC mode, runs device flow when no token given"
```

---

## Task 8: Update Helm chart for OIDC

**Files:**
- Modify: `charts/codewire-relay/values.yaml`
- Modify: `charts/codewire-relay/templates/deployment.yaml`

### Step 1: Add OIDC block to values.yaml

Add after the `relay:` block:

```yaml
oidc:
  # Set issuer to enable OIDC auth mode (e.g. https://auth.codewire.sh)
  issuer: ""
  clientID: ""
  # Reference to a Secret containing the client secret under key "oidc-client-secret"
  clientSecretRef:
    name: ""
    key: "oidc-client-secret"
  # Groups required for access. Empty = any authenticated user.
  allowedGroups: []
```

### Step 2: Update deployment.yaml to handle OIDC mode

Replace the current `{{- if eq .Values.relay.authMode "token" }}` block with a more complete env/args block:

```yaml
          {{- if eq .Values.relay.authMode "token" }}
          command: ["sh", "-c"]
          args:
            - |
              exec cw relay \
                --base-url={{ .Values.relay.baseURL | quote }} \
                --listen={{ .Values.relay.listenAddr | quote }} \
                --ssh-listen={{ .Values.relay.sshListen | quote }} \
                --data-dir=/data \
                --auth-mode={{ .Values.relay.authMode | quote }} \
                --auth-token="$CW_AUTH_TOKEN"
          {{- else if eq .Values.relay.authMode "oidc" }}
          command: ["sh", "-c"]
          args:
            - |
              exec cw relay \
                --base-url={{ .Values.relay.baseURL | quote }} \
                --listen={{ .Values.relay.listenAddr | quote }} \
                --ssh-listen={{ .Values.relay.sshListen | quote }} \
                --data-dir=/data \
                --auth-mode=oidc \
                --oidc-issuer={{ .Values.oidc.issuer | quote }} \
                --oidc-client-id={{ .Values.oidc.clientID | quote }} \
                --oidc-client-secret="$OIDC_CLIENT_SECRET" \
                {{- range .Values.oidc.allowedGroups }}
                --oidc-allowed-groups={{ . | quote }} \
                {{- end }}
          {{- else }}
          args:
            - relay
            - --base-url={{ .Values.relay.baseURL }}
            - --listen={{ .Values.relay.listenAddr }}
            - --ssh-listen={{ .Values.relay.sshListen }}
            - --data-dir=/data
            - --auth-mode={{ .Values.relay.authMode }}
          {{- end }}
          env:
            {{- if eq .Values.relay.authMode "token" }}
            - name: CW_AUTH_TOKEN
              valueFrom:
                secretKeyRef:
                  name: {{ include "codewire-relay.fullname" . }}
                  key: auth-token
            {{- end }}
            {{- if eq .Values.relay.authMode "oidc" }}
            - name: OIDC_CLIENT_SECRET
              valueFrom:
                secretKeyRef:
                  name: {{ .Values.oidc.clientSecretRef.name | default (include "codewire-relay.fullname" .) }}
                  key: {{ .Values.oidc.clientSecretRef.key }}
            {{- end }}
```

### Step 3: Build check (Helm lint)

```bash
helm lint charts/codewire-relay
```
Expected: no errors.

### Step 4: Commit

```bash
git add charts/codewire-relay/values.yaml charts/codewire-relay/templates/deployment.yaml
git commit -m "feat: add OIDC config to Helm chart"
```

---

## Task 9: Update operator for OIDC

**Files:**
- Modify: `operator/api/v1alpha1/types.go`
- Modify: `operator/api/v1alpha1/zz_generated.deepcopy.go`
- Modify: `operator/internal/controller/codewirerelay_controller.go`

### Step 1: Add OIDCSpec to types.go

Add after the `ImageSpec` struct:

```go
type OIDCSpec struct {
	// Issuer is the OIDC provider issuer URL (e.g. https://auth.codewire.sh).
	Issuer string `json:"issuer"`

	// ClientID is the registered OIDC client ID.
	ClientID string `json:"clientID"`

	// ClientSecretRef references a Secret containing the OIDC client secret.
	ClientSecretRef SecretKeyRef `json:"clientSecretRef"`

	// AllowedGroups restricts access to members of these groups.
	// Empty means any authenticated user is allowed.
	// +optional
	AllowedGroups []string `json:"allowedGroups,omitempty"`
}
```

Add to `CodewireRelaySpec`:
```go
	// OIDC configures OIDC authentication (authMode: "oidc").
	OIDC *OIDCSpec `json:"oidc,omitempty"`
```

### Step 2: Update zz_generated.deepcopy.go

In `CodewireRelaySpec.DeepCopyInto`, add after the `DNS` nil check block:

```go
	if in.OIDC != nil {
		in, out := &in.OIDC, &out.OIDC
		*out = new(OIDCSpec)
		(*in).DeepCopyInto(*out)
	}
```

Add new DeepCopy methods at the end of the file:

```go
// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OIDCSpec) DeepCopyInto(out *OIDCSpec) {
	*out = *in
	out.ClientSecretRef = in.ClientSecretRef
	if in.AllowedGroups != nil {
		in, out := &in.AllowedGroups, &out.AllowedGroups
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OIDCSpec.
func (in *OIDCSpec) DeepCopy() *OIDCSpec {
	if in == nil {
		return nil
	}
	out := new(OIDCSpec)
	in.DeepCopyInto(out)
	return out
}
```

### Step 3: Update controller to mount OIDC secret and pass env vars

In `codewirerelay_controller.go`, in the `buildDeployment` function (or wherever args/env are set for the relay container), add:

```go
// OIDC env vars (when authMode is "oidc" and OIDC spec is set).
if relay.Spec.AuthMode == "oidc" && relay.Spec.OIDC != nil {
    container.Env = append(container.Env, corev1.EnvVar{
        Name: "OIDC_CLIENT_SECRET",
        ValueFrom: &corev1.EnvVarSource{
            SecretKeyRef: &corev1.SecretKeySelector{
                LocalObjectReference: corev1.LocalObjectReference{
                    Name: relay.Spec.OIDC.ClientSecretRef.Name,
                },
                Key: relay.Spec.OIDC.ClientSecretRef.Key,
            },
        },
    })
    container.Args = append(container.Args,
        "--oidc-issuer="+relay.Spec.OIDC.Issuer,
        "--oidc-client-id="+relay.Spec.OIDC.ClientID,
        `--oidc-client-secret=$(OIDC_CLIENT_SECRET)`,
    )
    for _, g := range relay.Spec.OIDC.AllowedGroups {
        container.Args = append(container.Args, "--oidc-allowed-groups="+g)
    }
}
```

### Step 4: Build and test operator

```bash
cd /Users/noel/src/sonica/codewire/operator
go build ./...
go test ./... -timeout 60s -count=1
```
Expected: builds and tests pass.

### Step 5: Commit

```bash
git add operator/api/v1alpha1/types.go operator/api/v1alpha1/zz_generated.deepcopy.go \
        operator/internal/controller/codewirerelay_controller.go
git commit -m "feat: add OIDCSpec to operator CRD and controller env wiring"
```

---

## Task 10: Update operator CRD YAML

**Files:**
- Modify: `operator/config/crd/codewire.io_codewirerelays.yaml`
- Modify: `operator/config/samples/codewirerelay_sample.yaml`

### Step 1: Add OIDC fields to CRD YAML

In `codewire.io_codewirerelays.yaml`, under `spec.properties`, add after the `image` property:

```yaml
        oidc:
          description: OIDC configures OIDC authentication (authMode "oidc").
          properties:
            allowedGroups:
              description: AllowedGroups restricts access to members of these groups.
              items:
                type: string
              type: array
            clientID:
              description: ClientID is the registered OIDC client ID.
              type: string
            clientSecretRef:
              description: ClientSecretRef references a Secret containing the OIDC client secret.
              properties:
                key:
                  description: Key within the Secret.
                  type: string
                name:
                  description: Name of the Secret.
                  type: string
              required:
              - key
              - name
              type: object
            issuer:
              description: Issuer is the OIDC provider issuer URL.
              type: string
          required:
          - clientID
          - clientSecretRef
          - issuer
          type: object
```

### Step 2: Add OIDC to sample manifest

Add to `codewirerelay_sample.yaml` spec (as a commented example):

```yaml
  # OIDC authentication (uncomment to use instead of token mode):
  # authMode: oidc
  # oidc:
  #   issuer: https://auth.codewire.sh
  #   clientID: codewire-relay
  #   clientSecretRef:
  #     name: codewire-oidc-secret
  #     key: client-secret
  #   allowedGroups:
  #     - sonica
```

### Step 3: Build verify

```bash
cd /Users/noel/src/sonica/codewire/operator && go build ./...
```

### Step 4: Commit

```bash
git add operator/config/crd/codewire.io_codewirerelays.yaml operator/config/samples/codewirerelay_sample.yaml
git commit -m "feat: add OIDC spec to operator CRD YAML and sample"
```

---

## Task 11: Infra — add codewire-relay Dex client

**Files:**
- Modify: `/Users/noel/src/sonica/infra/components/terraform/dex/main.tf`
- Modify: `/Users/noel/src/sonica/infra/stacks/catalog/dex/_defaults.yaml`

### Step 1: Add codewire-relay to static_clients

In `dex/_defaults.yaml`, add `codewire-relay` to the `static_clients` list:

```yaml
        static_clients:
          - grafana
          - pangolin
          - kubernetes
          - kubernetes-codespace
          - kubernetes-app
          - infisical
          - headscale
          - codewire-relay    # ← add this
```

### Step 2: Add Infisical secret for the client secret in main.tf

After the `infisical_secret.infisical_client_secret` resource, add:

```hcl
# Store codewire-relay client secret in Infisical
resource "infisical_secret" "codewire_relay_client_secret" {
  folder_path  = "/"
  env_slug     = var.infisical_environment
  name         = "CODEWIRE_RELAY_DEX_CLIENT_SECRET"
  value        = random_password.dex_static_client_secret["codewire-relay"].result
  workspace_id = var.infisical_project_id
}
```

### Step 3: Register Dex client in Helm values

The Dex Helm chart values template (in main.tf) lists static clients. Find the `staticClients` section and add:

```yaml
- id: codewire-relay
  name: CodeWire Relay
  secret: "{{ .CODEWIRE_RELAY_DEX_CLIENT_SECRET.Value }}"
  redirectURIs:
    - https://{{ RELAY_BASE_URL }}/auth/oidc/callback
  grantTypes:
    - authorization_code
    - urn:ietf:params:oauth:grant-type:device_code
```

Note: Check how other clients (e.g. grafana, pangolin) are added in main.tf and follow the same pattern exactly. The Dex config is templated — look for `staticClients` in the Helm values template string in main.tf.

### Step 4: Verify Terraform plan (infra repo)

```bash
cd /Users/noel/src/sonica/infra
atmos terraform plan dex --stack system
```
Expected: plan shows adding `infisical_secret.codewire_relay_client_secret` and updating Dex config.

### Step 5: Commit infra changes

```bash
cd /Users/noel/src/sonica/infra
git add components/terraform/dex/main.tf stacks/catalog/dex/_defaults.yaml
git commit -m "feat: add codewire-relay OIDC client to Dex"
```

---

## Final verification

```bash
cd /Users/noel/src/sonica/codewire
go test ./internal/... ./tests/... -timeout 120s -count=1
go build ./...
```

Expected: all tests pass, binary builds clean.

Smoke test for `cw setup` flag change:
```bash
./cw setup --help
# Should show: setup <relay-url> [token]
# Should NOT show: --invite flag
# Should show: --token flag
```
